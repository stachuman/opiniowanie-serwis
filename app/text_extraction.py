# app/text_extraction.py
"""
Modu≈Ç ekstraktowania tekstu z r√≥≈ºnych typ√≥w dokument√≥w.
"""

import PyPDF2
from sqlmodel import Session, select
from pathlib import Path

from app.db import FILES_DIR, engine
from app.models import Document
from tasks.ocr.config import logger
import subprocess
import shutil

# Pr√≥ba importu biblioteki python-docx
try:
    from docx import Document as DocxDocument

    HAS_DOCX = True
except ImportError:
    HAS_DOCX = False

try:
    import docx2txt
    HAS_DOCX2TXT = True
except ImportError:
    HAS_DOCX2TXT = False

# Cache dla wyekstraktowanych tekst√≥w
extracted_text_cache = {}


def clear_text_cache(doc_id=None):
    """Czy≈õci cache tekst√≥w dla dokumentu lub ca≈Çkowicie."""
    global extracted_text_cache
    if doc_id is None:
        # Wyczy≈õƒá ca≈Çy cache
        extracted_text_cache.clear()
        print(f"üßπ [TEXT_EXTRACTION] Wyczyszczono ca≈Çy cache tekst√≥w")
    else:
        # Wyczy≈õƒá cache dla konkretnego dokumentu
        keys_to_remove = [k for k in extracted_text_cache.keys() if k.startswith(f"{doc_id}_")]
        for key in keys_to_remove:
            del extracted_text_cache[key]
        print(f"üßπ [TEXT_EXTRACTION] Wyczyszczono cache dla dokumentu {doc_id}")


def extract_text_from_pdf(file_path):
    """WyciƒÖga tekst z PDF u≈ºywajƒÖc PyPDF2."""
    try:
        with open(file_path, 'rb') as file:
            pdf_reader = PyPDF2.PdfReader(file)
            text = ""
            for page in pdf_reader.pages:
                text += page.extract_text() + "\n"
            return text.strip()
    except Exception as e:
        logger.warning(f"Nie mo≈ºna wyciƒÖgnƒÖƒá tekstu z PDF {file_path}: {str(e)}")
        return ""


def extract_text_from_word(file_path):
    """WyciƒÖga tekst z dokumentu Word - obs≈Çuguje wszystkie formaty."""

    # Metoda 1: Spr√≥buj jako .docx (nowy format)
    if HAS_DOCX:
        try:
            doc = DocxDocument(file_path)
            text = ""
            for paragraph in doc.paragraphs:
                text += paragraph.text + "\n"
            logger.info(f"‚úÖ Pomy≈õlnie odczytano .docx: {file_path}")
            return text.strip()
        except Exception as docx_error:
            logger.info(f"üìÑ Nie uda≈Ço siƒô odczytaƒá jako .docx: {docx_error}")

    # Metoda 2: Spr√≥buj przez antiword (najlepsza dla starych .doc)
    if shutil.which('antiword'):  # Sprawd≈∫ czy antiword jest zainstalowany
        try:
            result = subprocess.run(
                ['antiword', '-t', str(file_path)],  # -t = plain text output
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='ignore',
                timeout=30  # Timeout 30 sekund
            )

            if result.returncode == 0 and result.stdout.strip():
                text = result.stdout.strip()
                logger.info(f"‚úÖ Pomy≈õlnie odczytano przez antiword: {file_path} ({len(text)} znak√≥w)")
                return text
            else:
                logger.info(f"üìÑ Antiword nie mo≈ºe odczytaƒá: {file_path} (returncode: {result.returncode})")
        except subprocess.TimeoutExpired:
            logger.warning(f"‚è±Ô∏è Antiword timeout dla: {file_path}")
        except Exception as antiword_error:
            logger.info(f"üìÑ B≈ÇƒÖd antiword: {antiword_error}")
    else:
        logger.info("üìÑ Antiword nie jest zainstalowany - pomi≈Ñ starsze pliki .doc")

    # Metoda 3: Spr√≥buj python-docx2txt (backup)
    if HAS_DOCX2TXT:
        try:
            text = docx2txt.process(file_path)
            if text and text.strip():
                logger.info(f"‚úÖ Pomy≈õlnie odczytano przez docx2txt: {file_path}")
                return text.strip()
        except Exception as doc_error:
            logger.info(f"üìÑ Nie uda≈Ço siƒô odczytaƒá przez docx2txt: {doc_error}")

    # Metoda 4: Ostatnia szansa - catdoc (je≈õli dostƒôpny)
    if shutil.which('catdoc'):
        try:
            result = subprocess.run(
                ['catdoc', str(file_path)],
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='ignore',
                timeout=30
            )

            if result.returncode == 0 and result.stdout.strip():
                text = result.stdout.strip()
                logger.info(f"‚úÖ Pomy≈õlnie odczytano przez catdoc: {file_path}")
                return text
        except Exception as catdoc_error:
            logger.info(f"üìÑ B≈ÇƒÖd catdoc: {catdoc_error}")

    # Je≈õli nic nie zadzia≈Ça≈Ço
    missing_tools = []
    if not HAS_DOCX: missing_tools.append("python-docx")
    if not HAS_DOCX2TXT: missing_tools.append("python-docx2txt")
    if not shutil.which('antiword'): missing_tools.append("antiword")

    error_msg = f"Nie mo≈ºna odczytaƒá dokumentu Word. "
    if missing_tools:
        error_msg += f"BrakujƒÖce narzƒôdzia: {', '.join(missing_tools)}"

    logger.warning(f"‚ùå {error_msg}: {file_path}")
    return f"[B≈ÅƒÑD ODCZYTU] {error_msg}\n\nAby odczytaƒá ten plik, zainstaluj: sudo apt-get install antiword"

def get_ocr_text_for_document(doc_id, session):
    """Pobiera tekst OCR dla danego dokumentu - NAJNOWSZY dokument OCR."""
    try:
        # ‚úÖ POPRAWKA: Sortuj po upload_time DESC aby pobraƒá NAJNOWSZY dokument OCR
        ocr_txt_query = select(Document).where(
            Document.ocr_parent_id == doc_id,
            Document.doc_type == "OCR TXT"
        ).order_by(Document.upload_time.desc())  # NAJNOWSZY PIERWSZY

        ocr_txt = session.exec(ocr_txt_query).first()  # Teraz .first() bierze najnowszy

        if not ocr_txt:
            return ""

        # Debug log
        print(f"üîç [TEXT_EXTRACTION] Pobrano OCR dokument ID={ocr_txt.id}, upload_time={ocr_txt.upload_time}")

        # Odczytaj tekst z pliku OCR
        ocr_file_path = FILES_DIR / ocr_txt.stored_filename
        if not ocr_file_path.exists():
            print(f"‚ùå [TEXT_EXTRACTION] Plik OCR nie istnieje: {ocr_file_path}")
            return ""

        encodings = ['utf-8', 'latin-1', 'cp1250']
        for encoding in encodings:
            try:
                text = ocr_file_path.read_text(encoding=encoding)
                print(f"‚úÖ [TEXT_EXTRACTION] Odczytano OCR text ({len(text)} znak√≥w) z encoding={encoding}")
                return text
            except UnicodeDecodeError:
                continue

        print(f"‚ùå [TEXT_EXTRACTION] Nie mo≈ºna odczytaƒá pliku OCR z ≈ºadnym kodowaniem")
        return ""

    except Exception as e:
        print(f"‚ùå [TEXT_EXTRACTION] B≈ÇƒÖd podczas odczytu OCR dla dokumentu {doc_id}: {str(e)}")
        logger.warning(f"B≈ÇƒÖd podczas odczytu OCR dla dokumentu {doc_id}: {str(e)}")
        return ""


def get_document_text_content(document, session=None):
    """
    Zwraca tekstowƒÖ zawarto≈õƒá dokumentu.
    Dla dokument√≥w z OCR sprawdza zar√≥wno oryginalny plik jak i wyniki OCR.
    """
    cache_key = f"{document.id}_{document.stored_filename}_{document.last_modified or document.upload_time}"

    # Sprawd≈∫ cache
    if cache_key in extracted_text_cache:
        return extracted_text_cache[cache_key]

    file_path = FILES_DIR / document.stored_filename
    text_content = ""

    # Sprawd≈∫ czy plik istnieje
    if not file_path.exists():
        extracted_text_cache[cache_key] = ""
        return ""

    # WyciƒÖgnij tekst z oryginalnego pliku
    if document.mime_type == 'application/pdf':
        text_content = extract_text_from_pdf(file_path)
    elif document.mime_type and 'word' in document.mime_type:
        text_content = extract_text_from_word(file_path)
    elif document.mime_type == 'text/plain' or document.doc_type == "OCR TXT":
        # Dla plik√≥w tekstowych i wynik√≥w OCR
        try:
            encodings = ['utf-8', 'latin-1', 'cp1250']
            for encoding in encodings:
                try:
                    text_content = file_path.read_text(encoding=encoding)
                    break
                except UnicodeDecodeError:
                    continue
        except Exception as e:
            logger.warning(f"Nie mo≈ºna odczytaƒá pliku tekstowego {file_path}: {str(e)}")

    # WA≈ªNE: Je≈õli to dokument PDF/obrazek, sprawd≈∫ te≈º czy ma wyniki OCR
    if document.mime_type in ['application/pdf'] or (document.mime_type and document.mime_type.startswith('image/')):
        if session is None:
            # Utw√≥rz tymczasowƒÖ sesjƒô je≈õli nie zosta≈Ça przekazana
            with Session(engine) as temp_session:
                ocr_results = get_ocr_text_for_document(document.id, temp_session)
        else:
            ocr_results = get_ocr_text_for_document(document.id, session)

        # Dodaj wyniki OCR do tekstu (je≈õli istniejƒÖ i nie sƒÖ puste)
        if ocr_results and ocr_results.strip():
            text_content = f"{text_content}\n\n=== OCR RESULTS ===\n{ocr_results}".strip()

    # Zapisz w cache (max 2000 znak√≥w aby nie zu≈ºywaƒá za du≈ºo pamiƒôci)
    cached_text = text_content[:2000] if text_content else ""
    extracted_text_cache[cache_key] = cached_text

    return text_content


def get_text_preview(doc_id, max_length=None):
    """
    Pobiera tekst dokumentu dla podglƒÖdu.

    Args:
        doc_id: ID dokumentu
        max_length: Opcjonalne ograniczenie d≈Çugo≈õci (None = bez ogranicze≈Ñ)

    Returns:
        str: Tekst dokumentu
    """
    with Session(engine) as session:
        doc = session.get(Document, doc_id)
        if not doc:
            return "Nie znaleziono dokumentu"

        try:
            text_path = FILES_DIR / doc.stored_filename
            if not text_path.exists():
                return "Plik tekstowy nie istnieje"

            # Pr√≥ba odczytu z r√≥≈ºnymi kodowaniami
            encodings = ['utf-8', 'latin-1', 'cp1250']
            for encoding in encodings:
                try:
                    # Odczytaj pe≈Çny tekst dokumentu
                    text = text_path.read_text(encoding=encoding)
                    if max_length and len(text) > max_length:
                        return text[:max_length] + "...\n[Skr√≥cone - pobierz pe≈Çny tekst, aby zobaczyƒá wiƒôcej]"
                    return text
                except UnicodeDecodeError:
                    continue

            # Je≈õli ≈ºadne kodowanie nie zadzia≈Ça≈Ço
            return "Nie mo≈ºna odczytaƒá tekstu - nieobs≈Çugiwane kodowanie znak√≥w"
        except Exception as e:
            return f"B≈ÇƒÖd podczas odczytu tekstu: {str(e)}"