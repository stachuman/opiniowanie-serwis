{% extends 'base.html' %}
{% block content %}

<div class="container-fluid">
  <div class="row">
    <div class="col-12">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h2>Podgląd obrazu z zaznaczaniem</h2>
        <div>
          {% if doc.parent_id %}
          <!-- Gdy dokument ma rodzica (jest częścią opinii), wróć do widoku opinii -->
          <a href="{{ url_for('opinion_detail', doc_id=doc.parent_id) }}" class="btn btn-outline-secondary">
            <i class="bi bi-arrow-left"></i> Powrót do opinii
          </a>
          {% else %}
          <!-- Gdy dokument nie ma rodzica (jest samodzielny), wróć do widoku dokumentu -->
          <a href="{{ url_for('document_detail', doc_id=doc.id) }}" class="btn btn-outline-secondary">
            <i class="bi bi-arrow-left"></i> Powrót do dokumentu
          </a>
          {% endif %}

          <a href="{{ url_for('document_download', doc_id=doc.id) }}" class="btn btn-outline-primary">
            <i class="bi bi-download"></i> Pobierz obraz
          </a>

          <!-- Przycisk uruchamiania OCR -->
          {% if doc.ocr_status != 'running' %}
          <form action="{{ url_for('document_run_ocr', doc_id=doc.id) }}" method="post" class="d-inline">
            <button type="submit" class="btn btn-outline-warning">
              <i class="bi bi-magic"></i> Uruchom pełne OCR
            </button>
          </form>
          {% endif %}
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <!-- Kolumna z podglądem obrazu -->
    <div class="col-lg-8">
      <div class="card">
        <div class="card-header">
          <h5 class="mb-0">{{ doc.original_filename }}</h5>
        </div>
        <div class="card-body p-0 position-relative">
          <div id="imageContainer" style="height: 800px; position: relative; overflow: auto; display: flex; justify-content: center; align-items: center;">
            <div id="imageWrapper" style="position: relative; display: inline-block;">
              <img id="mainImage" src="{{ url_for('document_preview', doc_id=doc.id) }}"
                   alt="{{ doc.original_filename }}"
                   style="display: block; max-width: 100%; height: auto; cursor: crosshair;">
              <div id="selectionOverlay" style="position: absolute; top: 0; left: 0; border: 2px dashed #007bff; background-color: rgba(0, 123, 255, 0.2); display: none; pointer-events: none;"></div>
            </div>
          </div>

          <!-- Loader dla procesu OCR -->
          <div id="ocrLoader" class="position-absolute top-0 start-0 w-100 h-100 d-none"
               style="background: rgba(255,255,255,0.8); z-index: 100; display: flex; align-items: center; justify-content: center;">
            <div class="text-center">
              <div class="spinner-border text-primary mb-2" role="status">
                <span class="visually-hidden">Ładowanie...</span>
              </div>
              <div>Rozpoznawanie tekstu fragmentu...</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Kolumna z tekstem OCR -->
    <div class="col-lg-4">
      <div class="card">
        <div class="card-header">
          <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Rozpoznany tekst</h5>
            <button type="button" class="btn btn-sm btn-outline-info" id="toggleEditMode">
              <i class="bi bi-pencil"></i> Edytuj
            </button>
          </div>
        </div>
        <div class="card-body">
          <!-- Sekcja dla pełnego tekstu obrazu -->
          <div id="fullImageSection">
            <div class="d-flex justify-content-between mb-2">
              <h6 class="mb-0">Pełny tekst obrazu</h6>
              <div class="btn-group">
                <button id="saveChangesBtn" class="btn btn-sm btn-outline-success d-none" onclick="saveCurrentText()">
                  <i class="bi bi-save"></i> Zapisz zmiany
                </button>
                <button id="copyFullBtn" class="btn btn-sm btn-outline-secondary" data-copy-target="#textDisplay">
                  <i class="bi bi-clipboard"></i> Kopiuj całość
                </button>
              </div>
            </div>

            <!-- Wyświetlacz tekstu (tylko do odczytu) -->
            <div id="textDisplay" class="border rounded p-2" style="max-height: 500px; overflow-y: auto; white-space: pre-wrap; background-color: #f8f9fa; cursor: text; min-height: 100px;"></div>

            <!-- Edytor tekstu (ukryty domyślnie) -->
            <div id="textEditor" class="d-none">
              <textarea id="textEditArea" class="form-control" rows="20" style="font-family: 'Courier New', monospace; resize: vertical; min-height: 300px;"></textarea>
              <div class="mt-2 d-flex justify-content-between">
                <div class="text-muted small">
                  <i class="bi bi-info-circle me-1"></i>
                  Możesz edytować tekst aby poprawić błędy OCR przed zapisaniem.
                </div>
                <div>
                  <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="cancelEdit()">
                    <i class="bi bi-x"></i> Anuluj
                  </button>
                  <button type="button" class="btn btn-sm btn-success" onclick="saveEdit()">
                    <i class="bi bi-check"></i> Zatwierdź zmiany
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal dla rozpoznanego tekstu fragmentu -->
<div class="modal fade" id="fragmentTextModal" tabindex="-1" aria-labelledby="fragmentTextModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="fragmentTextModalLabel">
          <i class="bi bi-eye-fill me-2"></i>Rozpoznany tekst
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="alert alert-info">
          <i class="bi bi-info-circle me-2"></i>
          <strong>Tekst rozpoznany z zaznaczonego fragmentu:</strong>
        </div>
        <div class="card bg-light">
          <div class="card-body">
            <pre id="fragmentTextContent" class="mb-0" style="white-space: pre-wrap; max-height: 400px; overflow-y: auto;"></pre>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="copyFragmentBtn" type="button" class="btn btn-outline-secondary" data-copy-target="#fragmentTextContent">
          <i class="bi bi-clipboard"></i> Kopiuj tekst
        </button>
        <button type="button" class="btn btn-primary" onclick="addToFullText()">
          <i class="bi bi-plus-circle"></i> Dodaj do pełnego tekstu
        </button>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Zamknij</button>
      </div>
    </div>
  </div>
</div>

{% endblock %}

{% block scripts %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Elementy DOM
    var imageContainer = document.getElementById('imageContainer');
    var imageWrapper = document.getElementById('imageWrapper');
    var mainImage = document.getElementById('mainImage');
    var selectionOverlay = document.getElementById('selectionOverlay');
    var ocrLoader = document.getElementById('ocrLoader');

    // Zmienne pomocnicze
    var isSelecting = false;
    var startX, startY, endX, endY;
    var docId = {{ doc.id }};
    var currentFullImageOcr = null;
    var documentHasFullOcr = {{ 'true' if doc.ocr_status == 'done' else 'false' }};

    // Zmienne dla trybu edycji
    let isEditMode = false;
    let originalTextBeforeEdit = '';
    let originalText = '';
    let textChanged = false;

    // Główny element do wyświetlania tekstu
    let fullImageText = document.getElementById('textDisplay');

    // Funkcja sprawdzająca czy obraz został załadowany
    function waitForImageLoad() {
      if (mainImage.complete && mainImage.naturalHeight !== 0) {
        setupImageInteraction();
        if (documentHasFullOcr) {
          fetchFullImageOcr();
        } else {
          setupInitialMessage();
        }
        setupTextChangeMonitoring();
      } else {
        mainImage.onload = function() {
          setupImageInteraction();
          if (documentHasFullOcr) {
            fetchFullImageOcr();
          } else {
            setupInitialMessage();
          }
          setupTextChangeMonitoring();
        };
      }
    }

    // Konfiguracja początkowa
    function setupImageInteraction() {
      // Wyśrodkuj obraz
      imageContainer.style.display = 'flex';
      imageContainer.style.justifyContent = 'center';
      imageContainer.style.alignItems = 'center';
    }

    function setupInitialMessage() {
      // Najpierw sprawdź czy jest tekst na serwerze
      syncWithServer().then(hasServerText => {
        if (!hasServerText) {
          // Jeśli nie ma tekstu na serwerze, pokaż komunikat
          fullImageText.innerHTML = '<div class="alert alert-secondary">' +
            '<i class="bi bi-info-circle-fill me-2"></i> ' +
            'Brak pełnego OCR dla tego obrazu. Zaznacz fragment tekstu na obrazie, ' +
            'aby rozpoznać wybrany obszar.' +
            '</div>';
        }
      });
    }

    // Funkcja pobierająca tekst OCR dla całego obrazu
    function fetchFullImageOcr() {
      fullImageText.innerHTML = '<div class="d-flex justify-content-center">' +
        '<div class="spinner-border text-secondary" role="status">' +
        '<span class="visually-hidden">Ładowanie...</span>' +
        '</div>' +
        '</div>';

      // Najpierw spróbuj zsynchronizować z serwerem
      syncWithServer().then(hasServerText => {
        if (!hasServerText) {
          // Jeśli serwer nie ma tekstu, wykonaj OCR
          performOcrForImage();
        }
      }).catch(() => {
        // W przypadku błędu synchronizacji, wykonaj OCR
        performOcrForImage();
      });
    }

    // Wynieś logikę OCR do osobnej funkcji
    function performOcrForImage() {
      // Utwórz dane do wysłania (cały obraz)
      const data = {
        page: 1,
        x1: 0, y1: 0, x2: 1, y2: 1  // Cały obraz
      };

      // Wyślij zapytanie do API
      fetch('/api/document/' + docId + '/ocr-selection', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      })
      .then(function(response) { return response.json(); })
      .then(function(data) {
        if (data.success) {
          // Zapisz OCR całego obrazu
          currentFullImageOcr = data.text;
          // Wyświetl OCR
          updateDisplayText(data.text);
        } else {
          fullImageText.innerHTML = '<div class="alert alert-warning">' +
            '<i class="bi bi-exclamation-triangle-fill me-2"></i>' +
            (data.error || 'Nie udało się pobrać tekstu OCR') +
            '</div>';
        }
      })
      .catch(function(error) {
        fullImageText.innerHTML = '<div class="alert alert-danger">' +
          '<i class="bi bi-exclamation-triangle-fill me-2"></i>' +
          'Błąd: ' + error.message +
          '</div>';
      });
    }

    // Funkcja synchronizacji z serwerem przy ładowaniu strony
    async function syncWithServer() {
      try {
        const response = await fetch(`/api/document/${docId}/ocr-text`);
        const result = await response.json();

        if (result.success && result.has_ocr) {
          // Jeśli serwer ma tekst OCR, użyj go zamiast ponownego generowania
          currentFullImageOcr = result.text;
          updateDisplayText(result.text);

          // Pokaż info o synchronizacji (tylko jeśli tekst był już wyświetlany)
          if (fullImageText.textContent.trim()) {
            showSyncInfo();
          }

          return true; // Oznacza że znaleziono tekst na serwerze
        }
        return false; // Brak tekstu na serwerze
      } catch (error) {
        console.warn('Nie udało się zsynchronizować z serwerem:', error);
        return false;
      }
    }

    // Funkcja do przeliczania współrzędnych z CSS na względne (0-1)
    function calculateRelativeCoordinates(clientX, clientY) {
      var rect = mainImage.getBoundingClientRect();

      // Oblicz współrzędne kliknięcia względem obrazu
      var imageX = clientX - rect.left;
      var imageY = clientY - rect.top;

      // Zwróć znormalizowane współrzędne (0-1)
      return {
        x: Math.max(0, Math.min(1, imageX / rect.width)),
        y: Math.max(0, Math.min(1, imageY / rect.height))
      };
    }

    // Obsługa zaznaczania fragmentu
    imageWrapper.addEventListener('mousedown', function(e) {
      e.preventDefault();
      // Rozpocznij zaznaczanie
      isSelecting = true;

      // Pobierz pozycję kliknięcia względem obrazu
      var coords = calculateRelativeCoordinates(e.clientX, e.clientY);
      var rect = mainImage.getBoundingClientRect();
      startX = coords.x * rect.width;
      startY = coords.y * rect.height;

      // Ukryj poprzednie zaznaczenie
      hideSelection();
    });

    imageWrapper.addEventListener('mousemove', function(e) {
      if (!isSelecting) return;

      // Pobierz aktualną pozycję kursora
      var coords = calculateRelativeCoordinates(e.clientX, e.clientY);
      var rect = mainImage.getBoundingClientRect();
      endX = coords.x * rect.width;
      endY = coords.y * rect.height;

      // Oblicz wymiary prostokąta zaznaczenia
      var left = Math.min(startX, endX);
      var top = Math.min(startY, endY);
      var width = Math.abs(endX - startX);
      var height = Math.abs(endY - startY);

      // Pokaż zaznaczenie
      selectionOverlay.style.left = left + 'px';
      selectionOverlay.style.top = top + 'px';
      selectionOverlay.style.width = width + 'px';
      selectionOverlay.style.height = height + 'px';
      selectionOverlay.style.display = 'block';
    });

    imageWrapper.addEventListener('mouseup', function(e) {
      if (!isSelecting) return;

      // Zakończ zaznaczanie
      isSelecting = false;

      // Pobierz ostateczną pozycję kursora
      var coords = calculateRelativeCoordinates(e.clientX, e.clientY);
      var rect = mainImage.getBoundingClientRect();
      endX = coords.x * rect.width;
      endY = coords.y * rect.height;

      // Jeśli zaznaczenie jest zbyt małe, ignoruj je
      if (Math.abs(endX - startX) < 10 || Math.abs(endY - startY) < 10) {
        hideSelection();
        return;
      }

      // Oblicz współrzędne normalizowane (0-1)
      var rectImage = mainImage.getBoundingClientRect();
      var normX1 = Math.min(startX, endX) / rectImage.width;
      var normY1 = Math.min(startY, endY) / rectImage.height;
      var normX2 = Math.max(startX, endX) / rectImage.width;
      var normY2 = Math.max(startY, endY) / rectImage.height;

      console.log("Współrzędne zaznaczenia (0-1):", {
        x1: normX1, y1: normY1, x2: normX2, y2: normY2
      });

      // Pobierz OCR dla zaznaczonego fragmentu
      getSelectionOcr(normX1, normY1, normX2, normY2);
    });

    // Funkcja pobierająca OCR dla zaznaczonego fragmentu
    function getSelectionOcr(x1, y1, x2, y2) {
      // Pokaż loader
      ocrLoader.classList.remove('d-none');

      // Przygotuj dane do wysłania
      var data = {
        page: 1, // Obrazy mają zawsze 1 "stronę"
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        skip_pdf_embed: true // Nie osadzaj tekstu w PDF dla fragmentów
      };

      // Wyślij zapytanie do API
      fetch('/api/document/' + docId + '/ocr-selection', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      })
      .then(function(response) { return response.json(); })
      .then(function(data) {
        // Ukryj loader
        ocrLoader.classList.add('d-none');

        if (data.success) {
          // Wyświetl wynik w modalu
          showFragmentTextModal(data.text);
        } else {
          // Pokaż błąd w modalu
          showFragmentTextModal('Błąd: ' + (data.error || 'Nie udało się rozpoznać tekstu z fragmentu'));
        }
      })
      .catch(function(error) {
        // Ukryj loader
        ocrLoader.classList.add('d-none');

        // Pokaż błąd w modalu
        showFragmentTextModal('Błąd: ' + error.message);
      });
    }

    // Funkcja ukrywająca zaznaczenie
    function hideSelection() {
      selectionOverlay.style.display = 'none';
    }

    // Funkcja wyświetlająca modal z tekstem fragmentu
    function showFragmentTextModal(text) {
      const fragmentTextElement = document.getElementById('fragmentTextContent');
      const modalElement = document.getElementById('fragmentTextModal');

      // Jeśli element nie istnieje, spróbuj odtworzyć strukturę modala
      if (!fragmentTextElement || !modalElement) {
        console.warn('Elementy modala nie istnieją, próbuję odtworzyć...');
        restoreModalContent();
      }

      // Sprawdź ponownie po próbie odtworzenia
      const fragmentTextElementNew = document.getElementById('fragmentTextContent');
      const modalElementNew = document.getElementById('fragmentTextModal');

      if (!fragmentTextElementNew) {
        console.error('Element fragmentTextContent nie został znaleziony nawet po odtworzeniu');
        alert('Błąd interfejsu: nie można wyświetlić modala z tekstem');
        return;
      }

      if (!modalElementNew) {
        console.error('Element fragmentTextModal nie został znaleziony');
        alert('Błąd interfejsu: nie można wyświetlić modala');
        return;
      }

      fragmentTextElementNew.textContent = text;

      // Ustaw dedykowany event listener dla przycisku kopiowania
      setupModalCopyButton();

      const modal = new bootstrap.Modal(modalElementNew);
      modal.show();
    }

    // Funkcja konfigurująca przycisk kopiowania w modalu
    function setupModalCopyButton() {
      const copyBtn = document.getElementById('copyFragmentBtn');
      if (!copyBtn) {
        console.warn('Przycisk copyFragmentBtn nie został znaleziony');
        return;
      }

      // Usuń wszystkie poprzednie event listenery jeśli istnieją
      copyBtn.removeEventListener('click', handleModalCopyClick, { capture: true });
      copyBtn.removeEventListener('click', handleModalCopyClick);
      copyBtn.removeEventListener('click', handleModalCopyClickBackup);

      // Dodaj nowe event listenery
      copyBtn.addEventListener('click', handleModalCopyClick, { capture: true });
      copyBtn.addEventListener('click', handleModalCopyClickBackup);

      console.log('Skonfigurowano przyciski kopiowania dla modala');
    }

    // Handler dla kopiowania tekstu z modala
    async function handleModalCopyClick(e) {
      e.preventDefault();
      e.stopPropagation();

      console.log('Dedykowany handler modala - kopiowanie tekstu');

      const btn = e.currentTarget;
      const targetSelector = btn.getAttribute('data-copy-target');

      if (!targetSelector) {
        console.error('Brak atrybutu data-copy-target na przycisku');
        alert('Błąd konfiguracji: nie można określić tekstu do skopiowania');
        return;
      }

      const targetEl = document.querySelector(targetSelector);
      if (!targetEl) {
        console.error('Nie znaleziono elementu do skopiowania:', targetSelector);

        // Spróbuj odtworzyć modal i spróbuj ponownie
        restoreModalContent();
        const targetElNew = document.querySelector(targetSelector);
        if (!targetElNew) {
          alert('Błąd: nie można znaleźć tekstu do skopiowania');
          return;
        }
      }

      try {
        const textToCopy = (targetEl || document.querySelector(targetSelector)).innerText ||
                          (targetEl || document.querySelector(targetSelector)).textContent || '';

        if (!textToCopy.trim()) {
          alert('Brak tekstu do skopiowania');
          return;
        }

        console.log('Kopiowanie tekstu:', textToCopy.substring(0, 50) + '...');

        // Użyj agresywnej metody kopiowania dla modali
        await window.copyTextToClipboardAggressive(textToCopy, () => {
          window.flashCopied(btn);
        });

        console.log('Tekst skopiowany pomyślnie (dedykowany handler)');

      } catch (error) {
        console.error('Błąd kopiowania tekstu z modala:', error);
        alert('Nie udało się skopiować tekstu do schowka: ' + error.message);
      }
    }

    // Backup handler - w przypadku gdyby główny nie zadziałał
    async function handleModalCopyClickBackup(e) {
      // Sprawdź czy główny handler już obsłużył to zdarzenie
      if (e.defaultPrevented) {
        console.log('Backup handler - zdarzenie już obsłużone');
        return;
      }

      console.log('Backup handler - próba kopiowania');

      // Daj chwilę głównemu handlerowi
      setTimeout(async () => {
        if (e.defaultPrevented) return;

        console.log('Backup handler aktywny - kopiowanie tekstu');

        const btn = e.currentTarget;
        const targetSelector = btn.getAttribute('data-copy-target');
        const targetEl = document.querySelector(targetSelector);

        if (targetEl) {
          try {
            const textToCopy = targetEl.innerText || targetEl.textContent || '';
            if (textToCopy.trim()) {
              // Użyj agresywnej metody też w backup handlerze
              await window.copyTextToClipboardAggressive(textToCopy, () => {
                window.flashCopied(btn);
              });
              console.log('Backup handler - kopiowanie zakończone pomyślnie');
            }
          } catch (error) {
            console.error('Backup handler - błąd:', error);
          }
        }
      }, 100);
    }

    // Funkcja odtwarzająca oryginalną zawartość modala
    function restoreModalContent() {
      const modalElement = document.getElementById('fragmentTextModal');
      if (!modalElement) return;

      const modalBody = modalElement.querySelector('.modal-body');
      if (!modalBody) return;

      // Sprawdź czy element fragmentTextContent już istnieje
      if (modalBody.querySelector('#fragmentTextContent')) {
        // Już istnieje, tylko upewnij się że przycisk kopiowania działa
        setupModalCopyButton();
        return;
      }

      // Odtwórz oryginalną zawartość
      modalBody.innerHTML = `
        <div class="alert alert-info">
          <i class="bi bi-info-circle me-2"></i>
          <strong>Tekst rozpoznany z zaznaczonego fragmentu:</strong>
        </div>
        <div class="card bg-light">
          <div class="card-body">
            <pre id="fragmentTextContent" class="mb-0" style="white-space: pre-wrap; max-height: 400px; overflow-y: auto;"></pre>
          </div>
        </div>
      `;

      // Skonfiguruj przycisk kopiowania po odtworzeniu
      setTimeout(() => setupModalCopyButton(), 100);
    }

    // Funkcje do obsługi edycji tekstu
    function toggleEditMode() {
      const textDisplay = document.getElementById('textDisplay');
      const textEditor = document.getElementById('textEditor');
      const textEditArea = document.getElementById('textEditArea');
      const toggleBtn = document.getElementById('toggleEditMode');

      // Walidacja elementów
      if (!textDisplay || !textEditor || !textEditArea || !toggleBtn) {
        console.error('Nie można znaleźć elementów interfejsu edycji:', {
          textDisplay: !!textDisplay,
          textEditor: !!textEditor,
          textEditArea: !!textEditArea,
          toggleBtn: !!toggleBtn
        });
        alert('Błąd interfejsu: nie można przełączyć trybu edycji');
        return;
      }

      if (!isEditMode) {
        // Przejdź do trybu edycji
        const currentText = textDisplay.textContent || '';
        originalTextBeforeEdit = currentText;

        textEditArea.value = currentText;
        textDisplay.classList.add('d-none');
        textEditor.classList.remove('d-none');

        toggleBtn.innerHTML = '<i class="bi bi-eye"></i> Podgląd';
        toggleBtn.classList.remove('btn-outline-info');
        toggleBtn.classList.add('btn-outline-warning');

        isEditMode = true;

        // Focus na pole tekstowe
        textEditArea.focus();

      } else {
        // Przejdź do trybu podglądu
        exitEditMode(false); // false = nie zapisuj automatycznie
      }
    }

    function exitEditMode(autoSave = false) {
      const textDisplay = document.getElementById('textDisplay');
      const textEditor = document.getElementById('textEditor');
      const textEditArea = document.getElementById('textEditArea');
      const toggleBtn = document.getElementById('toggleEditMode');

      // Walidacja elementów
      if (!textDisplay || !textEditor || !textEditArea || !toggleBtn) {
        console.error('Nie można znaleźć elementów interfejsu edycji podczas wyjścia');
        return;
      }

      if (autoSave) {
        // Zaktualizuj wyświetlany tekst
        const editedText = textEditArea.value;
        updateDisplayText(editedText);
      }

      textDisplay.classList.remove('d-none');
      textEditor.classList.add('d-none');

      toggleBtn.innerHTML = '<i class="bi bi-pencil"></i> Edytuj';
      toggleBtn.classList.remove('btn-outline-warning');
      toggleBtn.classList.add('btn-outline-info');

      isEditMode = false;
    }

    function updateDisplayText(text) {
      const textDisplay = document.getElementById('textDisplay');

      // Aktualizuj wyświetlacz
      textDisplay.textContent = text;

      // Ustaw oryginalny tekst dla monitorowania zmian
      originalText = text;
    }

    // Obsługa zmiany rozmiaru okna
    window.addEventListener('resize', function() {
      // Ukryj zaznaczenie przy zmianie rozmiaru okna
      hideSelection();
    });

    // Zapobiegnij przeciąganiu obrazu
    mainImage.addEventListener('dragstart', function(e) {
      e.preventDefault();
    });

    // Obsługa skrótów klawiszowych
    document.addEventListener('keydown', function(e) {
      if (isEditMode) {
        // Ctrl+Enter = zapisz i wyjdź z edycji
        if (e.ctrlKey && e.key === 'Enter') {
          e.preventDefault();
          saveEdit();
        }
        // Escape = anuluj edycję
        else if (e.key === 'Escape') {
          e.preventDefault();
          cancelEdit();
        }
      } else {
        // E = przejdź do edycji (gdy nie jesteś w polu input)
        if (e.key === 'e' && !e.ctrlKey && !e.altKey &&
            document.activeElement.tagName !== 'INPUT' &&
            document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          toggleEditMode();
        }
      }
    });

    // Podłącz event listener do przycisku toggle
    const toggleBtn = document.getElementById('toggleEditMode');
    if (toggleBtn) {
      toggleBtn.addEventListener('click', toggleEditMode);
    } else {
      console.warn('Przycisk toggleEditMode nie został znaleziony - nie można dodać event listenera');
    }

    // Ustaw monitorowanie zmian tekstu
    function setupTextChangeMonitoring() {
      const textDisplay = document.getElementById('textDisplay');

      if (textDisplay) {
        // Obserwuj zmiany w tekście (używaj MutationObserver dla textContent)
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' || mutation.type === 'characterData') {
              checkForTextChanges();
            }
          });
        });

        observer.observe(textDisplay, {
          childList: true,
          subtree: true,
          characterData: true
        });
      }
    }

    function checkForTextChanges() {
      const textDisplay = document.getElementById('textDisplay');
      const currentText = textDisplay.textContent;
      const saveBtn = document.getElementById('saveChangesBtn');

      if (currentText !== originalText) {
        if (!textChanged) {
          textChanged = true;
          saveBtn.classList.remove('d-none');
          textDisplay.style.backgroundColor = '#fff3cd'; // Żółte tło
          textDisplay.style.border = '2px solid #ffc107';
        }
      } else {
        if (textChanged) {
          textChanged = false;
          saveBtn.classList.add('d-none');
          textDisplay.style.backgroundColor = '#f8f9fa';
          textDisplay.style.border = '';
        }
      }
    }

    // Globalne funkcje
    window.cancelEdit = function() {
      const textEditArea = document.getElementById('textEditArea');
      if (!textEditArea) {
        console.error('Element textEditArea nie został znaleziony');
        alert('Błąd interfejsu: nie można anulować edycji');
        return;
      }

      // Przywróć oryginalny tekst
      textEditArea.value = originalTextBeforeEdit;
      exitEditMode(false);
    };

    window.saveEdit = function() {
      const textEditArea = document.getElementById('textEditArea');
      if (!textEditArea) {
        console.error('Element textEditArea nie został znaleziony');
        alert('Błąd interfejsu: nie można zapisać edycji');
        return;
      }

      const editedText = textEditArea.value;

      // Sprawdź czy tekst się zmienił
      if (editedText !== originalTextBeforeEdit) {
        updateDisplayText(editedText);
        checkForTextChanges(); // Pokaż przycisk "Zapisz zmiany"
      }

      exitEditMode(true);
    };

    // Zmodyfikowana funkcja saveCurrentText
    window.saveCurrentText = async function() {
      const textDisplay = document.getElementById('textDisplay');
      const currentText = textDisplay.textContent;

      try {
        const formData = new FormData();
        formData.append('text_content', currentText);

        const response = await fetch(`/api/document/${docId}/update-ocr-text`, {
          method: 'POST',
          body: formData
        });

        const result = await response.json();

        if (result.success) {
          originalText = currentText;
          textChanged = false;
          document.getElementById('saveChangesBtn').classList.add('d-none');
          textDisplay.style.backgroundColor = '#f8f9fa';
          textDisplay.style.border = '';

          showSuccessAlert('Zmiany zostały zapisane', 'success', result.ocr_doc_id);
        } else {
          showErrorAlert('Nie udało się zapisać zmian: ' + (result.error || 'Nieznany błąd'));
        }

      } catch (error) {
        showErrorAlert('Błąd podczas zapisywania: ' + error.message);
      }
    };

    // Ulepszona funkcja showSuccessAlert z linkami powrotu
    function showSuccessAlert(message, type = 'success', ocrDocId = null) {
      const alertClass = type === 'success' ? 'alert-success' : 'alert-info';
      const iconClass = type === 'success' ? 'bi-check-circle' : 'bi-info-circle';

      // Przygotuj linki powrotu
      let returnLinks = '';
      {% if doc.parent_id %}
        // Dokument należy do opinii
        returnLinks = `
          <div class="mt-2">
            <a href="{{ url_for('opinion_detail', doc_id=doc.parent_id) }}?ocr_updated=true&ocr_doc_id=${ocrDocId || ''}"
               class="btn btn-sm btn-outline-dark me-2">
              <i class="bi bi-arrow-left"></i> Powrót do opinii
            </a>
            <a href="{{ url_for('document_detail', doc_id=doc.id) }}?ocr_updated=true&ocr_doc_id=${ocrDocId || ''}"
               class="btn btn-sm btn-outline-dark">
              <i class="bi bi-file-earmark"></i> Widok dokumentu
            </a>
          </div>
        `;
      {% else %}
        // Dokument samodzielny
        returnLinks = `
          <div class="mt-2">
            <a href="{{ url_for('document_detail', doc_id=doc.id) }}?ocr_updated=true&ocr_doc_id=${ocrDocId || ''}"
               class="btn btn-sm btn-outline-dark me-2">
              <i class="bi bi-arrow-left"></i> Widok dokumentu
            </a>
            <a href="{{ url_for('list_documents') }}"
               class="btn btn-sm btn-outline-dark">
              <i class="bi bi-files"></i> Lista dokumentów
            </a>
          </div>
        `;
      {% endif %}

      const alert = document.createElement('div');
      alert.className = `alert ${alertClass} alert-dismissible fade show position-fixed`;
      alert.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 350px; max-width: 450px;';
      alert.innerHTML = `
        <div class="d-flex align-items-start">
          <i class="${iconClass} me-2 mt-1"></i>
          <div class="flex-grow-1">
            <div class="fw-bold">${message}</div>
            <small class="text-muted">Tekst został zapisany na serwerze i będzie dostępny po powrocie do widoku dokumentu.</small>
            ${returnLinks}
          </div>
          <button type="button" class="btn-close ms-2" data-bs-dismiss="alert"></button>
        </div>
      `;
      document.body.appendChild(alert);

      // Usuń po 10 sekundach (dłużej dla ważnych komunikatów)
      setTimeout(() => {
        if (alert.parentNode) {
          alert.remove();
        }
      }, 10000);
    }

    function showErrorAlert(message) {
      const alert = document.createElement('div');
      alert.className = 'alert alert-danger alert-dismissible fade show position-fixed';
      alert.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
      alert.innerHTML = `
        <i class="bi bi-exclamation-triangle me-2"></i>${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      document.body.appendChild(alert);

      // Usuń po 7 sekund (błędy trzymamy dłużej)
      setTimeout(() => {
        if (alert.parentNode) {
          alert.remove();
        }
      }, 7000);
    }

    function showSyncInfo() {
      const alert = document.createElement('div');
      alert.className = 'alert alert-info alert-dismissible fade show position-fixed';
      alert.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
      alert.innerHTML = `
        <i class="bi bi-cloud-check me-2"></i>
        <strong>Synchronizacja z serwerem</strong><br>
        <small>Załadowano najnowszy tekst OCR z serwera.</small>
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      document.body.appendChild(alert);

      setTimeout(() => {
        if (alert.parentNode) {
          alert.remove();
        }
      }, 4000);
    }

    // Zaktualizowana funkcja addToFullText
    window.addToFullText = async function() {
      const fragmentTextElement = document.getElementById('fragmentTextContent');
      const modalElement = document.getElementById('fragmentTextModal');

      if (!fragmentTextElement) {
        console.error('Element fragmentTextContent nie został znaleziony');
        // Spróbuj odtworzyć zawartość modala
        restoreModalContent();
        const fragmentTextElementNew = document.getElementById('fragmentTextContent');
        if (!fragmentTextElementNew) {
          alert('Błąd interfejsu: nie można pobrać tekstu fragmentu');
          return;
        }
      }

      if (!modalElement) {
        console.error('Modal fragmentTextModal nie został znaleziony');
        alert('Błąd interfejsu: nie można znaleźć modala');
        return;
      }

      const fragmentText = (fragmentTextElement || document.getElementById('fragmentTextContent')).textContent;
      const currentFullText = fullImageText.textContent;

      // Przygotuj nowy tekst - dodaj fragment do istniejącego
      let newFullText;
      if (currentFullText && currentFullText.trim() && currentFullText.indexOf('Brak pełnego OCR') === -1) {
        newFullText = currentFullText + '\n\n--- Dodany fragment ---\n' + fragmentText;
      } else {
        newFullText = fragmentText;
      }

      // Pobierz lub utwórz instancję modala
      let modal = bootstrap.Modal.getInstance(modalElement);
      if (!modal) {
        modal = new bootstrap.Modal(modalElement);
      }

      const modalBody = modalElement.querySelector('.modal-body');
      if (!modalBody) {
        console.error('Nie można znaleźć .modal-body w modalu');
        alert('Błąd interfejsu: nieprawidłowa struktura modala');
        return;
      }

      const originalContent = modalBody.innerHTML;

      // Funkcja przywracająca zawartość w każdym przypadku
      const restoreContent = () => {
        if (modalBody) {
          modalBody.innerHTML = originalContent;
          // Przywróć również funkcjonalność kopiowania
          setTimeout(() => setupModalCopyButton(), 100);
        }
      };

      // Dodaj event listener na zamknięcie modala aby przywrócić zawartość
      const handleModalHidden = () => {
        restoreContent();
        modalElement.removeEventListener('hidden.bs.modal', handleModalHidden);
      };
      modalElement.addEventListener('hidden.bs.modal', handleModalHidden);

      // Wyświetl loader
      modalBody.innerHTML = `
        <div class="d-flex justify-content-center align-items-center py-4">
          <div class="spinner-border text-primary me-3" role="status">
            <span class="visually-hidden">Zapisywanie...</span>
          </div>
          <span>Zapisywanie tekstu do serwera...</span>
        </div>
      `;

      try {
        // Wyślij tekst do serwera
        const formData = new FormData();
        formData.append('text_content', newFullText);

        const response = await fetch(`/api/document/${docId}/update-ocr-text`, {
          method: 'POST',
          body: formData
        });

        const result = await response.json();

        if (result.success) {
          // Aktualizuj lokalny tekst
          updateDisplayText(newFullText);

          // Zapisz aktualny OCR w zmiennej globalnej
          currentFullImageOcr = newFullText;

          // Usuń event listener (już nie potrzebny)
          modalElement.removeEventListener('hidden.bs.modal', handleModalHidden);

          // Zamknij modal
          modal.hide();

          // Pokaż komunikat o powodzeniu z linkami
          showSuccessAlert(result.message, result.action === 'created' ? 'success' : 'info', result.ocr_doc_id);

        } else {
          // Przywróć zawartość modalu i pokaż błąd
          restoreContent();
          showErrorAlert('Nie udało się zapisać tekstu: ' + (result.error || 'Nieznany błąd'));
        }

      } catch (error) {
        // Przywróć zawartość modalu i pokaż błąd
        restoreContent();
        showErrorAlert('Błąd komunikacji z serwerem: ' + error.message);
      }
    };

    // Inicjalizacja po załadowaniu obrazu
    waitForImageLoad();

    // Upewnij się, że modal jest w prawidłowym stanie
    restoreModalContent();

    // Skonfiguruj przycisk kopiowania w modalu
    setupModalCopyButton();
  });
</script>

<style>
#textDisplay:hover {
  background-color: #e9ecef !important;
}

.edit-mode-hint {
  background-color: #d1ecf1;
  border: 1px solid #bee5eb;
  border-radius: 0.25rem;
  padding: 0.5rem;
  margin-bottom: 1rem;
}

/* Animacje przełączania trybów */
#textDisplay, #textEditor {
  transition: all 0.3s ease;
}
</style>
{% endblock %}