{% extends 'base.html' %}
{% block content %}

<div class="container-fluid">
  <div class="row">
    <div class="col-12">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h2>Podgląd obrazu z zaznaczaniem</h2>
        <div>
          {% if doc.parent_id %}
          <!-- Gdy dokument ma rodzica (jest częścią opinii), wróć do widoku opinii -->
          <a href="{{ url_for('opinion_detail', doc_id=doc.parent_id) }}" class="btn btn-outline-secondary">
            <i class="bi bi-arrow-left"></i> Powrót do opinii
          </a>
          {% else %}
          <!-- Gdy dokument nie ma rodzica (jest samodzielny), wróć do widoku dokumentu -->
          <a href="{{ url_for('document_detail', doc_id=doc.id) }}" class="btn btn-outline-secondary">
            <i class="bi bi-arrow-left"></i> Powrót do dokumentu
          </a>
          {% endif %}
          
          <a href="{{ url_for('document_download', doc_id=doc.id) }}" class="btn btn-outline-primary">
            <i class="bi bi-download"></i> Pobierz obraz
          </a>
          
          <!-- Przycisk uruchamiania OCR -->
          {% if doc.ocr_status != 'running' %}
          <form action="{{ url_for('document_run_ocr', doc_id=doc.id) }}" method="post" class="d-inline">
            <button type="submit" class="btn btn-outline-warning">
              <i class="bi bi-magic"></i> Uruchom pełne OCR
            </button>
          </form>
          {% endif %}
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <!-- Kolumna z podglądem obrazu -->
    <div class="col-lg-8">
      <div class="card">
        <div class="card-header">
          <h5 class="mb-0">{{ doc.original_filename }}</h5>
        </div>
        <div class="card-body p-0 position-relative">
          <div id="imageContainer" style="height: 800px; position: relative; overflow: auto; display: flex; justify-content: center; align-items: center;">
            <div id="imageWrapper" style="position: relative; display: inline-block;">
              <img id="mainImage" src="{{ url_for('document_preview', doc_id=doc.id) }}" 
                   alt="{{ doc.original_filename }}" 
                   style="display: block; max-width: 100%; height: auto; cursor: crosshair;">
              <div id="selectionOverlay" style="position: absolute; top: 0; left: 0; border: 2px dashed #007bff; background-color: rgba(0, 123, 255, 0.2); display: none; pointer-events: none;"></div>
            </div>
          </div>
          
          <!-- Loader dla procesu OCR -->
          <div id="ocrLoader" class="position-absolute top-0 start-0 w-100 h-100 d-none" 
               style="background: rgba(255,255,255,0.8); z-index: 100; display: flex; align-items: center; justify-content: center;">
            <div class="text-center">
              <div class="spinner-border text-primary mb-2" role="status">
                <span class="visually-hidden">Ładowanie...</span>
              </div>
              <div>Rozpoznawanie tekstu fragmentu...</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Kolumna z tekstem OCR -->
    <div class="col-lg-4">
      <div class="card">
        <div class="card-header">
          <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Rozpoznany tekst</h5>
            <button type="button" class="btn btn-sm btn-outline-info" id="toggleEditMode">
              <i class="bi bi-pencil"></i> Edytuj
            </button>
          </div>
        </div>
        <div class="card-body">
          <!-- Sekcja dla pełnego tekstu obrazu -->
          <div id="fullImageSection">
            <div class="d-flex justify-content-between mb-2">
              <h6 class="mb-0">Pełny tekst obrazu</h6>
              <div class="btn-group">
                <button id="saveChangesBtn" class="btn btn-sm btn-outline-success d-none" onclick="saveCurrentText()">
                  <i class="bi bi-save"></i> Zapisz zmiany
                </button>
                <button id="copyFullBtn" class="btn btn-sm btn-outline-secondary">
                  <i class="bi bi-clipboard"></i> Kopiuj całość
                </button>
              </div>
            </div>
            
            <!-- Wyświetlacz tekstu (tylko do odczytu) -->
            <div id="textDisplay" class="border rounded p-2" style="max-height: 500px; overflow-y: auto; white-space: pre-wrap; background-color: #f8f9fa; cursor: text; min-height: 100px;"></div>
            
            <!-- Edytor tekstu (ukryty domyślnie) -->
            <div id="textEditor" class="d-none">
              <textarea id="textEditArea" class="form-control" rows="20" style="font-family: 'Courier New', monospace; resize: vertical; min-height: 300px;"></textarea>
              <div class="mt-2 d-flex justify-content-between">
                <div class="text-muted small">
                  <i class="bi bi-info-circle me-1"></i>
                  Możesz edytować tekst aby poprawić błędy OCR przed zapisaniem.
                </div>
                <div>
                  <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="cancelEdit()">
                    <i class="bi bi-x"></i> Anuluj
                  </button>
                  <button type="button" class="btn btn-sm btn-success" onclick="saveEdit()">
                    <i class="bi bi-check"></i> Zatwierdź zmiany
                  </button>
                </div>
              </div>
            </div>
            
            <!-- Niewidoczny element textarea do kopiowania -->
            <textarea id="copyFullArea" style="position: absolute; left: -9999px;"></textarea>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal dla rozpoznanego tekstu fragmentu -->
<div class="modal fade" id="fragmentTextModal" tabindex="-1" aria-labelledby="fragmentTextModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="fragmentTextModalLabel">
          <i class="bi bi-eye-fill me-2"></i>Rozpoznany tekst
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="alert alert-info">
          <i class="bi bi-info-circle me-2"></i>
          <strong>Tekst rozpoznany z zaznaczonego fragmentu:</strong>
        </div>
        <div class="card bg-light">
          <div class="card-body">
            <pre id="fragmentTextContent" class="mb-0" style="white-space: pre-wrap; max-height: 400px; overflow-y: auto;"></pre>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" onclick="copyFragmentText()">
          <i class="bi bi-clipboard"></i> Kopiuj tekst
        </button>
        <button type="button" class="btn btn-primary" onclick="addToFullText()">
          <i class="bi bi-plus-circle"></i> Dodaj do pełnego tekstu
        </button>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Zamknij</button>
      </div>
    </div>
  </div>
</div>

{% endblock %}

{% block scripts %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Elementy DOM
    var imageContainer = document.getElementById('imageContainer');
    var imageWrapper = document.getElementById('imageWrapper');
    var mainImage = document.getElementById('mainImage');
    var selectionOverlay = document.getElementById('selectionOverlay');
    var copyFullBtn = document.getElementById('copyFullBtn');
    var ocrLoader = document.getElementById('ocrLoader');
    var copyFullArea = document.getElementById('copyFullArea');

    // Zmienne pomocnicze
    var isSelecting = false;
    var startX, startY, endX, endY;
    var docId = {{ doc.id }};
    var currentFullImageOcr = null;
    var documentHasFullOcr = {{ 'true' if doc.ocr_status == 'done' else 'false' }};
    
    // Zmienne dla trybu edycji
    let isEditMode = false;
    let originalTextBeforeEdit = '';
    let originalText = '';
    let textChanged = false;

    // Główny element do wyświetlania tekstu
    let fullImageText = document.getElementById('textDisplay');
    
    // Funkcja sprawdzająca czy obraz został załadowany
    function waitForImageLoad() {
      if (mainImage.complete && mainImage.naturalHeight !== 0) {
        setupImageInteraction();
        if (documentHasFullOcr) {
          fetchFullImageOcr();
        } else {
          setupInitialMessage();
        }
        setupTextChangeMonitoring();
      } else {
        mainImage.onload = function() {
          setupImageInteraction();
          if (documentHasFullOcr) {
            fetchFullImageOcr();
          } else {
            setupInitialMessage();
          }
          setupTextChangeMonitoring();
        };
      }
    }

    // Konfiguracja początkowa
    function setupImageInteraction() {
      // Wyśrodkuj obraz
      imageContainer.style.display = 'flex';
      imageContainer.style.justifyContent = 'center';
      imageContainer.style.alignItems = 'center';
    }

    function setupInitialMessage() {
      // Najpierw sprawdź czy jest tekst na serwerze
      syncWithServer().then(hasServerText => {
        if (!hasServerText) {
          // Jeśli nie ma tekstu na serwerze, pokaż komunikat
          fullImageText.innerHTML = '<div class="alert alert-secondary">' +
            '<i class="bi bi-info-circle-fill me-2"></i> ' +
            'Brak pełnego OCR dla tego obrazu. Zaznacz fragment tekstu na obrazie, ' +
            'aby rozpoznać wybrany obszar.' +
            '</div>';
        }
      });
    }

    // Funkcja pobierająca tekst OCR dla całego obrazu
    function fetchFullImageOcr() {
      fullImageText.innerHTML = '<div class="d-flex justify-content-center">' +
        '<div class="spinner-border text-secondary" role="status">' +
        '<span class="visually-hidden">Ładowanie...</span>' +
        '</div>' +
        '</div>';
      
      // Najpierw spróbuj zsynchronizować z serwerem
      syncWithServer().then(hasServerText => {
        if (!hasServerText) {
          // Jeśli serwer nie ma tekstu, wykonaj OCR
          performOcrForImage();
        }
      }).catch(() => {
        // W przypadku błędu synchronizacji, wykonaj OCR
        performOcrForImage();
      });
    }

    // Wynieś logikę OCR do osobnej funkcji
    function performOcrForImage() {
      // Utwórz dane do wysłania (cały obraz)
      const data = {
        page: 1,
        x1: 0, y1: 0, x2: 1, y2: 1  // Cały obraz
      };
      
      // Wyślij zapytanie do API
      fetch('/api/document/' + docId + '/ocr-selection', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      })
      .then(function(response) { return response.json(); })
      .then(function(data) {
        if (data.success) {
          // Zapisz OCR całego obrazu
          currentFullImageOcr = data.text;
          // Wyświetl OCR
          updateDisplayText(data.text);
        } else {
          fullImageText.innerHTML = '<div class="alert alert-warning">' +
            '<i class="bi bi-exclamation-triangle-fill me-2"></i>' +
            (data.error || 'Nie udało się pobrać tekstu OCR') +
            '</div>';
        }
      })
      .catch(function(error) {
        fullImageText.innerHTML = '<div class="alert alert-danger">' +
          '<i class="bi bi-exclamation-triangle-fill me-2"></i>' +
          'Błąd: ' + error.message +
          '</div>';
      });
    }

    // Funkcja synchronizacji z serwerem przy ładowaniu strony
    async function syncWithServer() {
      try {
        const response = await fetch(`/api/document/${docId}/ocr-text`);
        const result = await response.json();
        
        if (result.success && result.has_ocr) {
          // Jeśli serwer ma tekst OCR, użyj go zamiast ponownego generowania
          currentFullImageOcr = result.text;
          updateDisplayText(result.text);
          
          // Pokaż info o synchronizacji (tylko jeśli tekst był już wyświetlany)
          if (fullImageText.textContent.trim()) {
            showSyncInfo();
          }
          
          return true; // Oznacza że znaleziono tekst na serwerze
        }
        return false; // Brak tekstu na serwerze
      } catch (error) {
        console.warn('Nie udało się zsynchronizować z serwerem:', error);
        return false;
      }
    }

    // Funkcja do przeliczania współrzędnych z CSS na względne (0-1)
    function calculateRelativeCoordinates(clientX, clientY) {
      var rect = mainImage.getBoundingClientRect();
      
      // Oblicz współrzędne kliknięcia względem obrazu
      var imageX = clientX - rect.left;
      var imageY = clientY - rect.top;
      
      // Zwróć znormalizowane współrzędne (0-1)
      return {
        x: Math.max(0, Math.min(1, imageX / rect.width)),
        y: Math.max(0, Math.min(1, imageY / rect.height))
      };
    }

    // Obsługa zaznaczania fragmentu
    imageWrapper.addEventListener('mousedown', function(e) {
      e.preventDefault();
      // Rozpocznij zaznaczanie
      isSelecting = true;
      
      // Pobierz pozycję kliknięcia względem obrazu
      var coords = calculateRelativeCoordinates(e.clientX, e.clientY);
      var rect = mainImage.getBoundingClientRect();
      startX = coords.x * rect.width;
      startY = coords.y * rect.height;
      
      // Ukryj poprzednie zaznaczenie
      hideSelection();
    });

    imageWrapper.addEventListener('mousemove', function(e) {
      if (!isSelecting) return;
      
      // Pobierz aktualną pozycję kursora
      var coords = calculateRelativeCoordinates(e.clientX, e.clientY);
      var rect = mainImage.getBoundingClientRect();
      endX = coords.x * rect.width;
      endY = coords.y * rect.height;
      
      // Oblicz wymiary prostokąta zaznaczenia
      var left = Math.min(startX, endX);
      var top = Math.min(startY, endY);
      var width = Math.abs(endX - startX);
      var height = Math.abs(endY - startY);
      
      // Pokaż zaznaczenie
      selectionOverlay.style.left = left + 'px';
      selectionOverlay.style.top = top + 'px';
      selectionOverlay.style.width = width + 'px';
      selectionOverlay.style.height = height + 'px';
      selectionOverlay.style.display = 'block';
    });

    imageWrapper.addEventListener('mouseup', function(e) {
      if (!isSelecting) return;
      
      // Zakończ zaznaczanie
      isSelecting = false;
      
      // Pobierz ostateczną pozycję kursora
      var coords = calculateRelativeCoordinates(e.clientX, e.clientY);
      var rect = mainImage.getBoundingClientRect();
      endX = coords.x * rect.width;
      endY = coords.y * rect.height;
      
      // Jeśli zaznaczenie jest zbyt małe, ignoruj je
      if (Math.abs(endX - startX) < 10 || Math.abs(endY - startY) < 10) {
        hideSelection();
        return;
      }
      
      // Oblicz współrzędne normalizowane (0-1)
      var rectImage = mainImage.getBoundingClientRect();
      var normX1 = Math.min(startX, endX) / rectImage.width;
      var normY1 = Math.min(startY, endY) / rectImage.height;
      var normX2 = Math.max(startX, endX) / rectImage.width;
      var normY2 = Math.max(startY, endY) / rectImage.height;
      
      console.log("Współrzędne zaznaczenia (0-1):", {
        x1: normX1, y1: normY1, x2: normX2, y2: normY2
      });
      
      // Pobierz OCR dla zaznaczonego fragmentu
      getSelectionOcr(normX1, normY1, normX2, normY2);
    });

    // Funkcja pobierająca OCR dla zaznaczonego fragmentu
    function getSelectionOcr(x1, y1, x2, y2) {
      // Pokaż loader
      ocrLoader.classList.remove('d-none');
      
      // Przygotuj dane do wysłania
      var data = {
        page: 1, // Obrazy mają zawsze 1 "stronę"
        x1: x1, 
        y1: y1, 
        x2: x2, 
        y2: y2,
        skip_pdf_embed: true // Nie osadzaj tekstu w PDF dla fragmentów
      };
      
      // Wyślij zapytanie do API
      fetch('/api/document/' + docId + '/ocr-selection', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      })
      .then(function(response) { return response.json(); })
      .then(function(data) {
        // Ukryj loader
        ocrLoader.classList.add('d-none');
        
        if (data.success) {
          // Wyświetl wynik w modalu
          showFragmentTextModal(data.text);
        } else {
          // Pokaż błąd w modalu
          showFragmentTextModal('Błąd: ' + (data.error || 'Nie udało się rozpoznać tekstu z fragmentu'));
        }
      })
      .catch(function(error) {
        // Ukryj loader
        ocrLoader.classList.add('d-none');
        
        // Pokaż błąd w modalu
        showFragmentTextModal('Błąd: ' + error.message);
      });
    }

    // Funkcja ukrywająca zaznaczenie
    function hideSelection() {
      selectionOverlay.style.display = 'none';
    }

    // Funkcja wyświetlająca modal z tekstem fragmentu
    function showFragmentTextModal(text) {
      document.getElementById('fragmentTextContent').textContent = text;
      var modal = new bootstrap.Modal(document.getElementById('fragmentTextModal'));
      modal.show();
    }

    // Funkcje do obsługi edycji tekstu
    function toggleEditMode() {
      const textDisplay = document.getElementById('textDisplay');
      const textEditor = document.getElementById('textEditor');
      const textEditArea = document.getElementById('textEditArea');
      const toggleBtn = document.getElementById('toggleEditMode');
      
      if (!isEditMode) {
        // Przejdź do trybu edycji
        const currentText = textDisplay.textContent || '';
        originalTextBeforeEdit = currentText;
        
        textEditArea.value = currentText;
        textDisplay.classList.add('d-none');
        textEditor.classList.remove('d-none');
        
        toggleBtn.innerHTML = '<i class="bi bi-eye"></i> Podgląd';
        toggleBtn.classList.remove('btn-outline-info');
        toggleBtn.classList.add('btn-outline-warning');
        
        isEditMode = true;
        
        // Focus na pole tekstowe
        textEditArea.focus();
        
      } else {
        // Przejdź do trybu podglądu
        exitEditMode(false); // false = nie zapisuj automatycznie
      }
    }

    function exitEditMode(autoSave = false) {
      const textDisplay = document.getElementById('textDisplay');
      const textEditor = document.getElementById('textEditor');
      const textEditArea = document.getElementById('textEditArea');
      const toggleBtn = document.getElementById('toggleEditMode');
      
      if (autoSave) {
        // Zaktualizuj wyświetlany tekst
        const editedText = textEditArea.value;
        updateDisplayText(editedText);
      }
      
      textDisplay.classList.remove('d-none');
      textEditor.classList.add('d-none');
      
      toggleBtn.innerHTML = '<i class="bi bi-pencil"></i> Edytuj';
      toggleBtn.classList.remove('btn-outline-warning');
      toggleBtn.classList.add('btn-outline-info');
      
      isEditMode = false;
    }

    function updateDisplayText(text) {
      const textDisplay = document.getElementById('textDisplay');
      const copyArea = document.getElementById('copyFullArea');
      
      // Aktualizuj wyświetlacz
      textDisplay.textContent = text;
      copyArea.value = text;
      
      // Ustaw oryginalny tekst dla monitorowania zmian
      originalText = text;
    }

    // Obsługa kopiowania pełnego tekstu obrazu
    copyFullBtn.addEventListener('click', function() {
      var textToCopy = fullImageText.textContent.trim();
      
      copyTextToClipboard(textToCopy, function() {
        // Zmień wygląd przycisku na chwilę
        var originalText = copyFullBtn.innerHTML;
        copyFullBtn.innerHTML = '<i class="bi bi-check2"></i> Skopiowano!';
        copyFullBtn.classList.add('btn-success');
        copyFullBtn.classList.remove('btn-outline-secondary');
        
        setTimeout(function() {
          copyFullBtn.innerHTML = originalText;
          copyFullBtn.classList.remove('btn-success');
          copyFullBtn.classList.add('btn-outline-secondary');
        }, 2000);
      });
    });

    // Obsługa zmiany rozmiaru okna
    window.addEventListener('resize', function() {
      // Ukryj zaznaczenie przy zmianie rozmiaru okna
      hideSelection();
    });

    // Zapobiegnij przeciąganiu obrazu
    mainImage.addEventListener('dragstart', function(e) {
      e.preventDefault();
    });

    // Obsługa skrótów klawiszowych
    document.addEventListener('keydown', function(e) {
      if (isEditMode) {
        // Ctrl+Enter = zapisz i wyjdź z edycji
        if (e.ctrlKey && e.key === 'Enter') {
          e.preventDefault();
          saveEdit();
        }
        // Escape = anuluj edycję
        else if (e.key === 'Escape') {
          e.preventDefault();
          cancelEdit();
        }
      } else {
        // E = przejdź do edycji (gdy nie jesteś w polu input)
        if (e.key === 'e' && !e.ctrlKey && !e.altKey && 
            document.activeElement.tagName !== 'INPUT' && 
            document.activeElement.tagName !== 'TEXTAREA') {
          e.preventDefault();
          toggleEditMode();
        }
      }
    });

    // Podłącz event listener do przycisku toggle
    const toggleBtn = document.getElementById('toggleEditMode');
    if (toggleBtn) {
      toggleBtn.addEventListener('click', toggleEditMode);
    }

    // Ustaw monitorowanie zmian tekstu
    function setupTextChangeMonitoring() {
      const textDisplay = document.getElementById('textDisplay');
      
      if (textDisplay) {
        // Obserwuj zmiany w tekście (używaj MutationObserver dla textContent)
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' || mutation.type === 'characterData') {
              checkForTextChanges();
            }
          });
        });
        
        observer.observe(textDisplay, {
          childList: true,
          subtree: true,
          characterData: true
        });
      }
    }

    function checkForTextChanges() {
      const textDisplay = document.getElementById('textDisplay');
      const currentText = textDisplay.textContent;
      const saveBtn = document.getElementById('saveChangesBtn');
      
      if (currentText !== originalText) {
        if (!textChanged) {
          textChanged = true;
          saveBtn.classList.remove('d-none');
          textDisplay.style.backgroundColor = '#fff3cd'; // Żółte tło
          textDisplay.style.border = '2px solid #ffc107';
        }
      } else {
        if (textChanged) {
          textChanged = false;
          saveBtn.classList.add('d-none');
          textDisplay.style.backgroundColor = '#f8f9fa';
          textDisplay.style.border = '';
        }
      }
    }

    // Globalne funkcje
    window.cancelEdit = function() {
      // Przywróć oryginalny tekst
      document.getElementById('textEditArea').value = originalTextBeforeEdit;
      exitEditMode(false);
    };

    window.saveEdit = function() {
      const editedText = document.getElementById('textEditArea').value;
      
      // Sprawdź czy tekst się zmienił
      if (editedText !== originalTextBeforeEdit) {
        updateDisplayText(editedText);
        checkForTextChanges(); // Pokaż przycisk "Zapisz zmiany"
      }
      
      exitEditMode(true);
    };

    // Zmodyfikowana funkcja saveCurrentText
    window.saveCurrentText = async function() {
      const textDisplay = document.getElementById('textDisplay');
      const currentText = textDisplay.textContent;
      
      try {
        const formData = new FormData();
        formData.append('text_content', currentText);
        
        const response = await fetch(`/api/document/${docId}/update-ocr-text`, {
          method: 'POST',
          body: formData
        });
        
        const result = await response.json();
        
        if (result.success) {
          originalText = currentText;
          textChanged = false;
          document.getElementById('saveChangesBtn').classList.add('d-none');
          textDisplay.style.backgroundColor = '#f8f9fa';
          textDisplay.style.border = '';
          
          showSuccessAlert('Zmiany zostały zapisane', 'success', result.ocr_doc_id);
        } else {
          showErrorAlert('Nie udało się zapisać zmian: ' + (result.error || 'Nieznany błąd'));
        }
        
      } catch (error) {
        showErrorAlert('Błąd podczas zapisywania: ' + error.message);
      }
    };

    // Funkcja pomocnicza do kopiowania tekstu
    function copyTextToClipboard(text, successCallback) {
      // Metoda 1: Użyj Clipboard API
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text)
          .then(successCallback)
          .catch(function(error) {
            console.error('Błąd kopiowania przez Clipboard API:', error);
            // Metoda 2: Fallback - użyj elementu textarea
            fallbackCopyTextToClipboard(text, successCallback);
          });
      } else {
        // Brak dostępu do Clipboard API, użyj fallbacku
        fallbackCopyTextToClipboard(text, successCallback);
      }
    }

    // Funkcja pomocnicza - fallback dla starszych przeglądarek
    function fallbackCopyTextToClipboard(text, successCallback) {
      try {
        // Utwórz tymczasowy element textarea
        var textarea = document.createElement('textarea');
        textarea.value = text;
        
        // Ustaw styl, aby element był niewidoczny
        textarea.style.position = 'fixed';
        textarea.style.left = '-9999px';
        textarea.style.top = '0';
        
        // Dodaj do DOM, zaznacz tekst i skopiuj
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        
        // Wykonaj polecenie kopiowania
        var successful = document.execCommand('copy');
        
        // Usuń tymczasowy element
        document.body.removeChild(textarea);
        
        if (successful) {
          successCallback();
        } else {
          console.error('Kopiowanie nie powiodło się');
        }
      } catch (error) {
        console.error('Błąd podczas fallbackowego kopiowania:', error);
      }
    }

    // Ulepszona funkcja showSuccessAlert z linkami powrotu
    function showSuccessAlert(message, type = 'success', ocrDocId = null) {
      const alertClass = type === 'success' ? 'alert-success' : 'alert-info';
      const iconClass = type === 'success' ? 'bi-check-circle' : 'bi-info-circle';
      
      // Przygotuj linki powrotu
      let returnLinks = '';
      {% if doc.parent_id %}
        // Dokument należy do opinii
        returnLinks = `
          <div class="mt-2">
            <a href="{{ url_for('opinion_detail', doc_id=doc.parent_id) }}?ocr_updated=true&ocr_doc_id=${ocrDocId || ''}" 
               class="btn btn-sm btn-outline-dark me-2">
              <i class="bi bi-arrow-left"></i> Powrót do opinii
            </a>
            <a href="{{ url_for('document_detail', doc_id=doc.id) }}?ocr_updated=true&ocr_doc_id=${ocrDocId || ''}" 
               class="btn btn-sm btn-outline-dark">
              <i class="bi bi-file-earmark"></i> Widok dokumentu
            </a>
          </div>
        `;
      {% else %}
        // Dokument samodzielny
        returnLinks = `
          <div class="mt-2">
            <a href="{{ url_for('document_detail', doc_id=doc.id) }}?ocr_updated=true&ocr_doc_id=${ocrDocId || ''}" 
               class="btn btn-sm btn-outline-dark me-2">
              <i class="bi bi-arrow-left"></i> Widok dokumentu
            </a>
            <a href="{{ url_for('list_documents') }}" 
               class="btn btn-sm btn-outline-dark">
              <i class="bi bi-files"></i> Lista dokumentów
            </a>
          </div>
        `;
      {% endif %}
      
      const alert = document.createElement('div');
      alert.className = `alert ${alertClass} alert-dismissible fade show position-fixed`;
      alert.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 350px; max-width: 450px;';
      alert.innerHTML = `
        <div class="d-flex align-items-start">
          <i class="${iconClass} me-2 mt-1"></i>
          <div class="flex-grow-1">
            <div class="fw-bold">${message}</div>
            <small class="text-muted">Tekst został zapisany na serwerze i będzie dostępny po powrocie do widoku dokumentu.</small>
            ${returnLinks}
          </div>
          <button type="button" class="btn-close ms-2" data-bs-dismiss="alert"></button>
        </div>
      `;
      document.body.appendChild(alert);
      
      // Usuń po 10 sekundach (dłużej dla ważnych komunikatów)
      setTimeout(() => {
        if (alert.parentNode) {
          alert.remove();
        }
      }, 10000);
    }

    function showErrorAlert(message) {
      const alert = document.createElement('div');
      alert.className = 'alert alert-danger alert-dismissible fade show position-fixed';
      alert.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
      alert.innerHTML = `
        <i class="bi bi-exclamation-triangle me-2"></i>${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      document.body.appendChild(alert);
      
      // Usuń po 7 sekund (błędy trzymamy dłużej)
      setTimeout(() => {
        if (alert.parentNode) {
          alert.remove();
        }
      }, 7000);
    }

    function showSyncInfo() {
      const alert = document.createElement('div');
      alert.className = 'alert alert-info alert-dismissible fade show position-fixed';
      alert.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
      alert.innerHTML = `
        <i class="bi bi-cloud-check me-2"></i>
        <strong>Synchronizacja z serwerem</strong><br>
        <small>Załadowano najnowszy tekst OCR z serwera.</small>
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      document.body.appendChild(alert);
      
      setTimeout(() => {
        if (alert.parentNode) {
          alert.remove();
        }
      }, 4000);
    }

    // Zaktualizowana funkcja addToFullText
    window.addToFullText = async function() {
      const fragmentText = document.getElementById('fragmentTextContent').textContent;
      const currentFullText = fullImageText.textContent;
      
      // Przygotuj nowy tekst - dodaj fragment do istniejącego
      let newFullText;
      if (currentFullText && currentFullText.trim() && currentFullText.indexOf('Brak pełnego OCR') === -1) {
        newFullText = currentFullText + '\n\n--- Dodany fragment ---\n' + fragmentText;
      } else {
        newFullText = fragmentText;
      }
      
      // Wyświetl loader
      const modal = bootstrap.Modal.getInstance(document.getElementById('fragmentTextModal'));
      const modalBody = modal._element.querySelector('.modal-body');
      const originalContent = modalBody.innerHTML;
      
      modalBody.innerHTML = `
        <div class="d-flex justify-content-center align-items-center py-4">
          <div class="spinner-border text-primary me-3" role="status">
            <span class="visually-hidden">Zapisywanie...</span>
          </div>
          <span>Zapisywanie tekstu do serwera...</span>
        </div>
      `;
      
      try {
        // Wyślij tekst do serwera
        const formData = new FormData();
        formData.append('text_content', newFullText);
        
        const response = await fetch(`/api/document/${docId}/update-ocr-text`, {
          method: 'POST',
          body: formData
        });
        
        const result = await response.json();
        
        if (result.success) {
          // Aktualizuj lokalny tekst
          updateDisplayText(newFullText);
          
          // Zapisz aktualny OCR w zmiennej globalnej
          currentFullImageOcr = newFullText;
          
          // Zamknij modal
          modal.hide();
          
          // Pokaż komunikat o powodzeniu z linkami
          showSuccessAlert(result.message, result.action === 'created' ? 'success' : 'info', result.ocr_doc_id);
          
        } else {
          // Przywróć zawartość modalu i pokaż błąd
          modalBody.innerHTML = originalContent;
          showErrorAlert('Nie udało się zapisać tekstu: ' + (result.error || 'Nieznany błąd'));
        }
        
      } catch (error) {
        // Przywróć zawartość modalu i pokaż błąd
        modalBody.innerHTML = originalContent;
        showErrorAlert('Błąd komunikacji z serwerem: ' + error.message);
      }
    };

    // Globalne funkcje dla modala
    window.copyFragmentText = function() {
      const text = document.getElementById('fragmentTextContent').textContent;
      copyTextToClipboard(text, function() {
        // Pokaż potwierdzenie
        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="bi bi-check2"></i> Skopiowano!';
        button.classList.add('btn-success');
        button.classList.remove('btn-outline-secondary');
        
        setTimeout(() => {
          button.innerHTML = originalText;
          button.classList.remove('btn-success');
          button.classList.add('btn-outline-secondary');
        }, 2000);
      });
    };

    // Inicjalizacja po załadowaniu obrazu
    waitForImageLoad();
  });
</script>

<style>
#textDisplay:hover {
  background-color: #e9ecef !important;
}

.edit-mode-hint {
  background-color: #d1ecf1;
  border: 1px solid #bee5eb;
  border-radius: 0.25rem;
  padding: 0.5rem;
  margin-bottom: 1rem;
}

/* Animacje przełączania trybów */
#textDisplay, #textEditor {
  transition: all 0.3s ease;
}
</style>
{% endblock %}
